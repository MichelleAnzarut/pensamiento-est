# Inferencia por intervalos

En esta parte consideramos hacer inferencia a una población.
Quiséramos decir algo acerca de la mediana de una población cuando solo
tenemos información parcial.

En este ejemplo, queremos aprender acerca de los precios de casas en una
región determinada (los precios están en miles de dólares).

```{r}
#| include: false
#| message: false
#| echo: false
#| warning: false
library(tidyverse)
source("R/casas_preprocesamiento.R")
datos_casas <- casas |> select(id, precio_miles) |> 
  mutate(orden = dense_rank(precio_miles))
```

Supongamos que tenemos la siguiente datos, que sólo son parte de la población:

```{r}
set.seed(6622)
muestra <- datos_casas |> slice_sample(n = 20)
muestra
ggplot(muestra, aes(sample = precio_miles ) ) +
  geom_qq(distribution = stats::qunif)
```

Supongamos que queremos estimar el valor $m$ que es la mediana poblacional. 
Este valor
tiene la propiedad de que separa a los datos en dos grupos de tamaño igual.

:::callout-tip

Estimar en este caso significa dar un rango donde creemos creíble que
el valor poblacional está. No tiene sentido dar un sólo valor pues no conocemos
la población total, así que tendremos incertidumbre de dónde está la mediana verdadera

::: 

Para construir estos rangos haremos algunos cálculos básicos.


En primer lugar, si observáramos un valor $y$ en la muestra, ¿cuál es la probabilidad de
que caiga por arriba de la mediana? Si no sabemos cómo se extrajo la muestra,
o se extrajo bajo un mecanismo complicado, esta pregunta es difícil de contestar.

Sin embargo, si este valor se extrajo **tomando un valor al azar entre todos los
de la población**, entonces sabemos que la probabilidad es

$$P(y <= m) = 0.5$$
:::callout-tip
# Aleatorización al rescate
Supondremos que cada elemento de la muestra se extrajo de la población
total al azar, cada uno de manera independiente de los otros.
:::

Con esta idea básica, 
podríamos por ejemplo calcular: ¿cuál es la probabilidad, de que
la mediana esté entre los valores  el mínimo y el
máximo de la muestra?
 
Denotemos por $y_1,y_2,\ldots, y_n$ la muestra observada. Denotaremos a la
muestra ordenada del valor más chico al valor más grande como
$$y_{(1)}, y_{(2)}, \ldots, y_{(n)}$$

Nuestra primera pregunta entonces es:

- ¿Cuál es la probabilidad de el valor de la mediana verdadera esté en el
intervalo $[y_{(1)}, y_{(n)}]$

*Respuesta*: La probabilidad de que la mediana esté por debajo del mínimo
$y_{(1)}$
de la muestra es $(1/2)^n$, pues todos los valores de la muestra tienen
que caer por arriba de la mediana. La probabilidad de que la mediana esté
por arriba del máximo $y_{(1)}$ es también $(1/2)^n$. Así que la probabilidad
de el verdadero valor de la mediana esté en este intervalo es de $ 2(1/2)^n$
 
Esta es la probabilidad de tirar solamente soles o solamente águilas en $n$
tiradas de una moneda, Si $X$ denota el número de soles obtenidos en $n$
tiradas de dados, buscamos calcular la probabilidad de que la mediana esté en 
intervalo como

$$1 - P(X > n - 1) - P(X \leq 0) = 1 - 2(1/2)^n$$

```{r}
#! code-fold: false
n <- 20
bajo <- 1
alto <- n - bajo + 1
1 - pbinom(alto - 1, 20, 0.5, lower.tail = FALSE) - pbinom(bajo - 1, 20, 0.5)
1- 2*(1/2)^20
```
Prácticamente, es casi seguro que este intervalo contenga
a la media verdadero. Esto no es muy informativo. Probemos ahora con 
 $[y_{(2)}, y_{(n-1)}]$. Por un argumento similar, la probabilidad de la
 mediana verdadera esté en este intervalo es:
 
```{r}
#! code-fold: false
n <- 20
bajo <- 2
alto <- n - bajo + 1
1 - pbinom(alto - 1, 20, 0.5, lower.tail = FALSE) - pbinom(bajo - 1, 20, 0.5)
```
Esto también es altamente probable. Sin embargo, la 
probabilidad de la mediana poblacional esté entre 
$[y_{6}, y_{15}]$ es

```{r}
#! code-fold: false
n <- 20
bajo <- 7
alto <- n - bajo + 1
1 - pbinom(alto - 1, 20, 0.5, lower.tail = FALSE) - pbinom(bajo - 1, 20, 0.5)
```
Así, este intervalo tiene probabilidad de casi 90% de probabilidad de
contener al verdadero valor:

- Esta es una probabilidad que se refiere al conjunto de muestras posibles de los
datos. Es altamente probable que este intervalo *cubra* al verdadero valor.


Ahora extraemos el intervalo correspondiente:

```{r}
intervalo <- muestra |> mutate(pos = dense_rank(precio_miles)) |> 
  arrange(pos) |> 
  filter(pos %in% c(7, 14))
intervalo |> select(pos, precio_miles)
```
Y este es un intervalo de confianza de cerca de 90% para la mediana de la población.
Cuando tomamos muestras más grandes, podemos obtener mejores precisiones. Por ejemplo,
para una muestra de 151 casas, usaríamos

```{r}
n <- 151
bajo <- 65
alto <- n - bajo - 1
cobertura <- 1 - pbinom(alto - 1, n, 0.5, lower.tail = FALSE) - pbinom(bajo - 1, n, 0.5)
cobertura
```
Tomamos una muestra y extraemos el intervalo:

```{r}
set.seed(3555881)
muestra_2 <- datos_casas |> slice_sample(n = 151, replace = TRUE) |> 
  mutate(pos = row_number(precio_miles)) 
muestra_2 |> 
  arrange(pos) |> 
  filter(pos %in% c(bajo, alto)) |> 
  select(precio_miles, pos)
```

Esto intervalos tienen la garantía inferencial, y no es necesario hacer
ningún supuesto, excepto en que la muestra se escoge al azar.

## Remuestreo

Podemos pensar en este procedimiento de una manera diferente. 

Si la muestra completa se seleccionó al azar, entonces, si escogemos un
valor no observado en la muestra, tenemos que $y$ tiene la misma 
probabilidad de caer en cualquiera de los intervalos 
$$I_1 = (0, y_1), I_2 = [y_1, y_2), I_3 = [y_2, y_3),\ldots, I_{n} = [y_{n}, \infty ]$$

La razón es que si consideramos la muestra original con el nuevo dato agregado
tomado al azar,
todos los ordenamientos de $y_1, y_2, \ldots, y_n, y_{n+1}$ son igualmente
probables: esto implica que es igualmente probable que $y_{n+1}$ 
caiga en cualquiera de estos intervalos (probabilidad $1/{n+1}$).

1. Podemos imputar nuestra población entera tomando escogiendo para cada valor
no observado un intervalo, 
2. Podemos entonces muestrear de esta población otra vez para obtener una muestra nueva.
3. Repetimos los dos anteriores una gran cantidad de veces para ver todos los
posibles valores de medianas que podemos obtener.


Cada muestra es una sucesión de intervalos. 
Acumulamos para obtener una distribución sobre estos
intervalos. La probabilidad de uqe la mediana salga en alguno de los intervalos
extremos es igual a

$$(1/n)^{n/2},$$
que es un número del orden de $$10^{-5}$$, que es chico aún cuando $n=10$. Para valores más grandes, 
esta probabilidad es astronómicamente chica. Como el intervalo final
consistirá de datos observados en nuestra muestra, en el resto de los intervalos
no importa donde están los verdaderos poblacionales, y nos basta con saber
si están o no en cada intervalo.

Este proceso se llama remuestreo, y lo hacemos a continuación

```{r}
remuestrear <- function(muestra){
  slice_sample(muestra, prop = 1, replace = TRUE) |> 
  summarise(mediana = median(precio_miles))
}
remuestras <- map_df(1:10000, ~ remuestrear(muestra))
```


```{r}
ggplot(remuestras, aes(x = mediana)) +
  geom_histogram(breaks = muestra |> pull(precio_miles)) +
  geom_rug()
```

```{r}
quantile(remuestras$mediana, c(0.051, 0.948), type = 8)
```
y obtenemos un resultado idéntico al argumento de arriba. La cobertura es prácticamente
exacta, y no afecta al resultado lo que sucede en las colas de la
distribución, gracias a que estamos usando la mediana.

## Remuestreo para otras estadísticas

Podemos repetir este método para otras estadísticas como la media. Sin embargo,
en este caso no podemos dar garantías independientes de la distribución poblacional.
La razón es que las colas pueden ser muy extremas. 

```{r}
#| code-fold: false
remuestrear_media <- function(muestra){
  slice_sample(muestra, prop = 1, replace = TRUE) |> 
  summarise(media = mean(precio_miles))
}
remuestras_media <- map_df(1:10000, ~ remuestrear_media(muestra))

```

```{r}
ggplot(remuestras_media) +
  geom_histogram(aes(x = media), binwidth = 1.5) +
  geom_rug(data = muestra, aes(x = precio_miles))
```

Y nuestro problema en este caso es que la media sí cambia dependiendo de cómo
es la distribución dentro de cada intervalo, incluyendo los intervalos izquierdo
y derecho.


