# Inferencia por intervalos

En esta parte consideramos hacer inferencia a una población.
Quiséramos decir algo acerca de la mediana de una población, si solo
tenemos información parcial.


```{r}
library(tidyverse)
source("R/casas_preprocesamiento.R")
casas
```
```{r}
datos_casas <- casas |> select(id, precio_miles) |> 
  mutate(orden = dense_rank(precio_miles))
```

Supongamos que tenemos la siguiente muestra:

```{r}
set.seed(6622)
muestra <- datos_casas |> slice_sample(n = 20)
muestra
ggplot(muestra, aes(sample = precio_miles ) ) +
  geom_qq(distribution = stats::qunif)
```

El resto de los valores poblacionales están distribuidos en el eje y. 
Queremos estimar el valor $m$ que es la mediana poblacional. Este valor
tiene la propiedad de que separa a los datos en dos grupos de tamaño igual.

Si observáramos un valor $y$ en la muestra, ¡cuál es la probabilidad de
que caiga por arriba de la mediana? Si no sabemos cómo se extrajo la muestra,
o se extrajo bajo un mecanismo complicado, esta pregunta es difícil de contestar.

Sin embargo, si este valor se extrajo tomando un valor al azar entre todos los
de la población, entonces sabemos que la probabilidad es

$$P(y <= m) = 0.5$$


Ahora podemos calcular: cuál es la probabilidad, por ejemplo, de que
la mediana esté entre los valores $y_{(2)}$ y $y_{(n-1)}$?
 
- La probabilidad de que  la mediana sea menor a $y_{(1)}$ es la probabilidad
 de que todos los valores de la muestra caigan por arriba de la mediana. Esta
 probabilidad es $(1/2)^n$ (tirar 0 soles en n volados)
 - La probabilidad de que la mediana sea menor a $y_{(2)}$ es la probabilidad 
 (tirar 0 o 1 sol en n volados)
- La probabilidad de que la mediana sea menor a $y_{(3)}$ es la probabilidad 
de tirar 0,1 o 2 soles en n volados).

Estas probabilidades las podemos calcular fácilmente. La probabilidad de
que la mediana esté entre los valores $[y_{j}, y_{n-j+1}]$ puede calcularse analíticamente
para nuestro ejemplo, tenemos una muestra

- $n= 20$

La probabilidad de la mediana poblacional esté entre 
$[y_{7}, y_{14}]$ es

```{r}
pbinom(14, 20, 0.5) - pbinom(6, 20, 0.5)
```
De manera que tomando






Consideramos la tabla completa de casas, ordenada por el precio en miles.

```{r}
intervalo <- muestra |> mutate(pos = dense_rank(precio_miles)) |> 
  arrange(pos) |> 
  filter(pos %in% c(7, 14))
intervalo |> select(pos, precio_miles)
```
Y este es un intervalo de confianza de al menos 90% para la mediana de la población.
Cuando tomamos muestras más grandes, podemos obtener mejores precisiones. Por ejemplo,
para una muestra de 150 casas, usaríamos

```{r}
n <- 151
bajo <- 65
alto <- n - bajo - 1
pbinom(alto, n, 0.5) 
pbinom(bajo, n, 0.5)
cobertura <- pbinom(alto, n, 0.5) - pbinom(bajo - 1, n, 0.5)
cobertura
```


```{r}
set.seed(3555881)
muestra_2 <- datos_casas |> slice_sample(n = 151, replace = TRUE) |> 
  mutate(pos = row_number(precio_miles)) 
muestra_2 |> 
  arrange(pos) |> 
  filter(pos %in% c(bajo, alto))
```


Esto intervalos tienen la garantía inferencial, y no es necesario hacer
ningún supuesto, excepto en que la muestra se escoge al azar.

## Remuestreo

Podemos pensar en este procedimiento de una manera diferente. 

Si la muestra completa se seleccionó de esta manera, entonces, si escogemos un
valor no observado en la muestra, tenemos que $y$ tiene la misma 
probabilidad de caer en cualquiera de los intervalos 
$$I_1 = (0, y_1), I_2 = [y_1, y_2), I_3 = [y_2, y_3),\ldots, I_{n} = [y_{n}, \infty ]$$

La razón es que si consideramos la muestra original con el nuevo dato agregado
tomado al azar,
todos los ordenamientos de $y_1, y_2, \ldots, y_n, y_{n+1}$ son igualmente
probables: esto implica que es igualmente probable que $y_{n+1}$ 
caiga en cualquiera de estos intervalos (probabilidad $1/{n+1}$).

Podemos imputar nuestra población entera tomando escogiendo para cada valor
no observado un intervalo, y muestreamos de esta población
repetidamente para calcular nuestra distribución de muestreo.

Cada muestra es una sucesión de intervalos. 
Acumulamos para obtener una distribución sobre estos
intervalos. La probabilidad de uqe la mediana salga en alguno de los intervalos
extremos es igual a

$$(1/n)^{n/2},$$
que es un número del orden de $$10^{-5}$$, que es chico aún cuando $n=10$. Para valores más grandes, 
esta probabilidad es astronómicamente chica. Podemos hacer una distribución

```{r}
remuestrear <- function(muestra){
  slice_sample(muestra, prop = 1, replace = TRUE) |> 
  summarise(mediana = median(precio_miles))
}
remuestras <- map_df(1:10000, ~ remuestrear(muestra))
```


```{r}
ggplot(remuestras, aes(x = mediana)) +
  geom_histogram(breaks = muestra |> pull(precio_miles)) +
  geom_rug()
```
```{r}
quantile(remuestras$mediana, c(0.051, 0.948), type = 8)
```
y obtenemos un resultado idéntico al argumento de arriba. La cobertura es prácticamente
exacta, y no afecta al resultado lo que sucede en las colas de la
distribución, gracias a que estamos usando la mediana.

## Remuestreo para otras estadísticas

Podemos repetir este método para otras estadísticas como la media. Sin embargo,
en este caso no podemos dar garantías independientes de la distribución poblacional.
La razón es que las colas pueden ser muy extremas. 

```{r}
#| code-fold: false
remuestrear_media <- function(muestra){
  slice_sample(muestra, prop = 1, replace = TRUE) |> 
  summarise(media = mean(precio_miles))
}
remuestras_media <- map_df(1:10000, ~ remuestrear_media(muestra))

```

```{r}
ggplot(remuestras_media) +
  geom_histogram(aes(x = media), binwidth = 1.5) +
  geom_rug(data = muestra, aes(x = precio_miles))
```

Y nuestro problema en este caso es que la media sí cambia dependiendo de cómo
es la distribución dentro de cada intervalo, incluyendo los intervalos izquierdo
y derecho.


