set.seed(882)
test_tbl <- dplyr::tibble(
state = c(rep("A", 10), rep("B", 10), rep("C", 5), rep("D", 4)),
x = rnorm(29),
cand_1 = sample(4:7, 29, replace=T),
cand_2 = sample(8:12, 29, replace=T),
otro = sample(0:3, 29, replace=T)) |>
dplyr::mutate(total = cand_1 + cand_2 + otro,
ln = sample(60:90, 29, replace=T), LISTA_NOMINAL=ln)
test_tbl
data_stratum <- test_tbl |>
dplyr::group_by(state) |>
dplyr::count()
data_stratum
sample_tbl <-
select_sample_prop(test_tbl, stratum = state, frac = 0.5, seed = 912)
library("quickcountmx")
sample_tbl <-
select_sample_prop(test_tbl, stratum = state, frac = 0.5, seed = 912)
sample_tbl
data_tbl = sample_tbl
stratum = "state"
data_stratum
n
std_errors = TRUE
seed = 12
parties = cand_1:otro
party_names <- names(data_tbl |> select( {{ cand_1:otro}}))
party_names <- names(data_tbl |> select(cand_1:otro))
library("tydiverse")
library("tidyverse")
party_names <- names(data_tbl |> select(cand_1:otro))
party_names
data_tbl <- data_tbl %>%
ungroup() %>%
rename(strata = state)
data_tbl
data_tbl$strata
data_stratum$strata
data_stratum
data_stratum <- data_stratum %>%
rename(strata = state, n_strata = n)
data_stratum
data_stratum$strata
n_distinct(data_tbl$strata)
n_distinct(data_stratum$strata
)
data_stratum_collapsed <- data_stratum
data_tbl <- data_tbl %>%
left_join(data_stratum_collapsed, by = "strata")
data_tbl
data_tbl %>%
mutate(internal_id = row_number())  %>%
group_by(strata) %>%
mutate(n_h = n()) %>%
ungroup()
a <- data_tbl %>%
mutate(internal_id = row_number())  %>%
group_by(strata) %>%
mutate(n_h = n()) %>%
ungroup()
view(a)
party_names
cand_1:otro
data_long_tbl <- data_tbl %>%
mutate(internal_id = row_number())  %>%
group_by(strata) %>%
mutate(n_h = n()) %>%
ungroup() %>%
tidyr::pivot_longer(cols = cand_1:otro, names_to = "party", values_to = "n_votes")
data_long_tbl
data_stratum
?nest
data_long_tbl |>
group_by(strata, party, n_strata) |>
tidyr::nest()
a <- data_long_tbl |>
group_by(strata, party, n_strata) |>
tidyr::nest()
a[[1,]]
a[1,]
estimates_tbl <- data_long_tbl |>
group_by(strata, party, n_strata) |>
tidyr::nest() |>
mutate(model = map(data, ~ lm(n_votes ~ -1 + ln, data = .x,  weights =  1 / ln ))) |>
mutate(estimate = map_dbl(model, ~ coef(.x)[1]))
estimates_tbl
?lm
estimates_tbl |>
unnest(c(data))
estimates_tbl[1]
estimates_tbl[1,]
estimates_tbl[,1]
estimates_tbl[[1]]
estimates_tbl[[1,]]
estimates_tbl[[,1]]
estimates_tbl
estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop")
estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand)
estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand) |>
group_by(party) |>
summarise(total_est_cand = sum(total_est_cand))
estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand) |>
group_by(party) |>
summarise(total_est_cand = sum(total_est_cand)) |>
ungroup() |>
mutate(total_est = sum(total_est_cand))
estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand) |>
group_by(party) |>
summarise(total_est_cand = sum(total_est_cand)) |>
ungroup() |>
mutate(total_est = sum(total_est_cand)) |>
mutate(prop = total_est_cand / total_est)
estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand) |>
group_by(party) |>
summarise(total_est_cand = sum(total_est_cand)) |>
ungroup() |>
mutate(total_est = sum(total_est_cand)) |>
mutate(prop = total_est_cand / total_est) |>
select(party, prop)
total_estimates_tbl <- estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand) |>
group_by(party) |>
summarise(total_est_cand = sum(total_est_cand)) |>
ungroup() |>
mutate(total_est = sum(total_est_cand)) |>
mutate(prop = total_est_cand / total_est) |>
select(party, prop)
total_estimates_tbl
estimates_tbl
models_tbl = estimates_tbl |> select(strata, n_strata, party, data, model)
models_tbl
B
B = 50
party_names
sd_normal_estimation <- function(data_tbl, models_tbl, data_stratum, B, party_names){
# B bootstrap replicates
#party_names <- names(data_tbl |> select( {{ parties}}))
model_reps <- purrr::rerun(B,
sd_normal_estimation_aux(data_tbl = data_tbl, models_tbl = models_tbl,
data_stratum = data_stratum, party_names = party_names))
std_errors <- bind_rows(model_reps) %>%
group_by(party) %>%
summarise(std_error = stats::sd(prop), .groups = "drop")
return(std_errors)
}
model_reps <- purrr::rerun(B,
sd_normal_estimation_aux(data_tbl = data_tbl, models_tbl = models_tbl,
data_stratum = data_stratum, party_names = party_names))
collapse_strata
?bayesglm
?collapse_strata
??collapse_strata
data_stratum_collapsed <- collapse_strata(data_tbl, data_stratum)
collapse_strata <- function(data_tbl, data_stratum){
data_obs <- data_tbl %>%
count(strata, name = "n_observed") %>%
mutate(strata = as.character(strata))
data_missings <- data_stratum %>%
mutate(strata = as.character(strata)) %>%
left_join(data_obs, by = "strata")
data_strata_collapsed <- data_missings %>%
rowwise() %>%
mutate(strata = ifelse(is.na(n_observed),
sample(stats::na.omit(data_missings$strata), 1),
strata)) %>%
group_by(strata) %>%
summarise(n_strata = sum(n_strata)) %>%
ungroup()
data_strata_collapsed
}
x = c(3, 5, 7, 9, 11, 13)
x
binomSize = 15 # known size of binomial
n = length(x) # sample size
thetahat = mean(x)/binomSize # MLE for Î¸
thetahat
nboot = 5000
tmpdata = rbinom(n*nboot, binomSize, thetahat)
bootstrapsample = matrix(tmpdata, nrow=n, ncol=nboot)
thetahatstar = colMeans(bootstrapsample)/binomSize
deltastar = thetahatstar - thetahat
d = quantile(deltastar, c(.1,.9))
ci = thetahat - c(d[2], d[1])
d
?ar.
?ar.m
?arm::sim
#' Normal model estimator to compute proportion of votes allocated to each party
#'
#' Compute estimator for each candidate, standard errors are computed
#' with parametric boostrap within each stratum and computing the standard
#' error of the samples (no corrections).
#' @param data_tbl \code{tibble}
#' @param stratum Unquoted variable indicating the stratum for each polling
#'   station.
#' @param data_stratum Data frame with stratum variable (named exactly as in
#'   \code{data}) and number of polling stations per strata.
#' @param n_stratum Unquoted variable indicating the number of polling stations
#'   in each stratum.
#' @param parties Unquoted variables indicating the number of votes in each polling
#'   station for each candidate.
#' @param std_errors Logical value indicating whether to compute standard errors
#'  (using bootstrap), defaults to TRUE.
#' @param B Number of parametric bootstrap replicates used to compute standard errors,
#'  defaults to 50.
#' @param seed integer value used to set the state of the random number
#' generator (optional). It will only be used when computing standard errors.
#' @return A \code{tibble} including the ratio estimation for each party
#'   and standard errors (if requested).
#' @examples
#' # count number of polling stations per stratum
#' library(dplyr)
#' conteo_2018 <- conteo_2018 %>%
#'     dplyr::rename(LISTA_NOMINAL = LISTA_NOMINAL_CASILLA)
#' stratum_sizes <- conteo_2018 %>%
#'     dplyr::group_by(ID_DISTRITO) %>%
#'     dplyr::summarise(n_stratum = n())
#' # stratified random sample (size 6%), sample size proportional to strata size
#' sample <- select_sample_prop(conteo_2018, stratum = ID_DISTRITO, 0.06)
#' normal_estimation(sample, stratum = ID_DISTRITO,
#'   data_stratum = stratum_sizes, n_stratum = n_stratum, any_of(c("AMLO", "JAMK")))
#' @importFrom dplyr %>%
#' @importFrom rlang :=
#' @importFrom purrr map
#' @importFrom purrr map_dbl
#' @export
normal_estimation <- function(data_tbl, stratum, data_stratum, n_stratum, parties,
std_errors = TRUE, B = 50, seed = NA){
party_names <- names(data_tbl |> select( {{ parties}}))
data_stratum <- data_stratum %>%
rename(strata = {{ stratum }}, n_strata = {{ n_stratum }})
# calculate estimates
data_tbl <- data_tbl %>%
ungroup() %>%
rename(strata = {{ stratum }})
# collapse strata if needed
if(n_distinct(data_tbl$strata) < n_distinct(data_stratum$strata)) {
data_stratum_collapsed <- collapse_strata(data_tbl, data_stratum)
} else {
data_stratum_collapsed <- data_stratum
}
data_tbl <- data_tbl %>%
left_join(data_stratum_collapsed, by = "strata")
data_long_tbl <- data_tbl %>%
mutate(internal_id = row_number())  %>%
group_by(strata) %>%
mutate(n_h = n()) %>%
ungroup() %>%
tidyr::pivot_longer(cols = {{ parties }}, names_to = "party", values_to = "n_votes")
estimates_tbl <- data_long_tbl |>
group_by(strata, party, n_strata) |>
tidyr::nest() |>
mutate(model = map(data, ~ lm(n_votes ~ -1 + ln, data = .x,  weights =  1 / ln ))) |>
mutate(estimate = map_dbl(model, ~ coef(.x)[1]))
total_estimates_tbl <- estimates_tbl |>
unnest(c(data)) |>
group_by(party, strata, n_strata) |>
summarise(mean_est_cand = mean( estimate * ln), .groups = "drop") |>
mutate(total_est_cand = n_strata * mean_est_cand) |>
group_by(party) |>
summarise(total_est_cand = sum(total_est_cand)) |>
ungroup() |>
mutate(total_est = sum(total_est_cand)) |>
mutate(prop = total_est_cand / total_est) |>
select(party, prop)
#    group_by(party) %>%
#    summarise(total_votes = sum(n_votes), .groups = "drop") %>%
#    mutate(prop = 100 * total_votes / sum(total_votes)) %>%
#    select(-total_votes)
#  ratio_part <-  data_long_tbl %>%
#    group_by(strata, n_h, n_strata, internal_id, LISTA_NOMINAL) %>%
#    summarise(total_votes = sum(n_votes)) %>%
#    group_by(strata, n_h, n_strata) %>%
#    summarise(total_votes_str = sum(total_votes),
#              total_ln_str = sum(LISTA_NOMINAL)) %>%
#    mutate(total = total_votes_str * n_strata / n_h,
#           total_nominal = total_ln_str * n_strata / n_h) %>%
#    ungroup() %>%
#    summarise(prop = 100 * sum(total) / sum(total_nominal)) %>%
#    mutate(party = "part")
#  ratios <- bind_rows(ratios, ratio_part)
if (std_errors == TRUE) {
estimates_sd <- sd_normal_estimation(
data_tbl = data_tbl,
models_tbl = estimates_tbl |> select(strata, n_strata, party, data, model),
data_stratum = data_stratum,
B = B, party_names = party_names)
total_estimates_tbl <- left_join(total_estimates_tbl, estimates_sd, by = "party") %>%
arrange(desc(prop))
}
return(total_estimates_tbl)
}
sd_normal_estimation <- function(data_tbl, models_tbl, data_stratum, B, party_names){
# B bootstrap replicates
#party_names <- names(data_tbl |> select( {{ parties}}))
model_reps <- purrr::rerun(B,
sd_normal_estimation_aux(data_tbl = data_tbl, models_tbl = models_tbl,
data_stratum = data_stratum, party_names = party_names))
std_errors <- bind_rows(model_reps) %>%
group_by(party) %>%
summarise(std_error = stats::sd(prop), .groups = "drop")
return(std_errors)
}
# auxiliary function, bootstrap samples of the data and computes ratio estimator
sd_normal_estimation_aux <- function(data_tbl, models_tbl, data_stratum, party_names){
#party_names <- names(data_tbl |> select( {{ parties}}))
#sample_boot <- select_sample_prop(data_tbl, stratum = strata, frac = 1,
#                                  replace = TRUE)
sample_boot <- models_tbl |>
mutate(params = map(model,  ~ arm::sim(.x, n.sims = 1))) |>
mutate(est_mean = map_dbl(params, ~ .x@coef[1,]),
est_sigma = map_dbl(params, ~ .x@sigma[1])) |>
tidyr::unnest(c(data)) |>
mutate(mean_votes = est_mean * ln) |>
mutate(n_votes = rnorm(length(est_mean), mean_votes, est_sigma)) |>
ungroup() |>
dplyr::select(internal_id, strata, party, LISTA_NOMINAL, ln, n_votes) |>
pivot_wider(names_from = "party", values_from = "n_votes")
normal_estimation(data_tbl = sample_boot,
stratum = strata, data_stratum = data_stratum, n_stratum = n_strata,
parties = all_of(party_names), std_errors = FALSE)
}
estimates <- normal_estimation(sample_tbl, stratum = state,
data_stratum = data_stratum,
n_stratum = n,
std_errors = TRUE, seed = 12, parties = cand_1:otro)
set.seed(882)
test_tbl <- dplyr::tibble(
state = c(rep("A", 10), rep("B", 10), rep("C", 5), rep("D", 4)),
x = rnorm(29),
cand_1 = sample(4:7, 29, replace=T),
cand_2 = sample(8:12, 29, replace=T),
otro = sample(0:3, 29, replace=T)) |>
dplyr::mutate(total = cand_1 + cand_2 + otro,
ln = sample(60:90, 29, replace=T), LISTA_NOMINAL=ln)
data_stratum <- test_tbl |>
dplyr::group_by(state) |>
dplyr::count()
sample_tbl <-
select_sample_prop(test_tbl, stratum = state, frac = 0.5, seed = 912)
estimates <- normal_estimation(sample_tbl, stratum = state,
data_stratum = data_stratum,
n_stratum = n,
std_errors = TRUE, seed = 12, parties = cand_1:otro)
estimates
set.seed(882)
test_tbl <- dplyr::tibble(
state = c(rep("A", 10), rep("B", 10), rep("C", 5), rep("D", 1)),
x = rnorm(29),
cand_1 = sample(4:7, 29, replace=T),
cand_2 = sample(8:12, 29, replace=T),
otro = sample(0:3, 29, replace=T)) |>
dplyr::mutate(total = cand_1 + cand_2 + otro,
ln = sample(60:90, 29, replace=T), LISTA_NOMINAL=ln)
set.seed(882)
test_tbl <- dplyr::tibble(
state = c(rep("A", 10), rep("B", 10), rep("C", 9), rep("D", 1)),
x = rnorm(29),
cand_1 = sample(4:7, 29, replace=T),
cand_2 = sample(8:12, 29, replace=T),
otro = sample(0:3, 29, replace=T)) |>
dplyr::mutate(total = cand_1 + cand_2 + otro,
ln = sample(60:90, 29, replace=T), LISTA_NOMINAL=ln)
set.seed(882)
test_tbl <- dplyr::tibble(
state = c(rep("A", 10), rep("B", 10), rep("C", 8), rep("D", 1)),
x = rnorm(29),
cand_1 = sample(4:7, 29, replace=T),
cand_2 = sample(8:12, 29, replace=T),
otro = sample(0:3, 29, replace=T)) |>
dplyr::mutate(total = cand_1 + cand_2 + otro,
ln = sample(60:90, 29, replace=T), LISTA_NOMINAL=ln)
data_stratum <- test_tbl |>
dplyr::group_by(state) |>
dplyr::count()
sample_tbl <-
select_sample_prop(test_tbl, stratum = state, frac = 0.5, seed = 912)
estimates <- normal_estimation(sample_tbl, stratum = state,
data_stratum = data_stratum,
n_stratum = n,
std_errors = TRUE, seed = 12, parties = cand_1:otro)
estimates
